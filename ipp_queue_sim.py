from __future__ import annotations

# ---------------------------------------------------------------------
# Standard library
# ---------------------------------------------------------------------
import argparse
import dataclasses
import itertools
import math
import random
import sys
import time
from abc import ABC, abstractmethod
from enum import Enum, auto
from typing import Any, Iterable, List, Sequence

# ---------------------------------------------------------------------
# Third‑party
# ---------------------------------------------------------------------
import numpy as np
import pandas as pd
from dataclasses import dataclass, field
from scipy import stats

__all__ = [
    "Parameters",
    "EventType",
    "EventRecord",
    "SimulationResults",
    "Metric",
    "BusyPeriodMetric",
    "BurstinessMetric",
    "IPPArrivalProcess",
    "IPPQueueSimulator",
    "parameter_grid",
    "sweep",
]

# =====================================================================
# Data classes / basic enums
# =====================================================================
class EventType(Enum):
    """Enumerates discrete events generated by the simulator."""

    ARRIVAL = auto()
    DEPARTURE = auto()
    STATE_CHANGE = auto()  # OFF→ON or ON→OFF in the IPP Markov chain


@dataclass(slots=True)
class EventRecord:
    """Lightweight container for an event logged during simulation."""

    time: float  # simulation clock when event occurred
    queue_len: int  # number of customers *in queue* **after** the event
    event: EventType
    extra: dict[str, Any] = field(default_factory=dict)  # optional, task‑specific


@dataclass(slots=True)
class Parameters:
    """All numeric inputs required to instantiate a simulation run."""

    # IPP Markov chain
    omega_off_to_on: float  # ω₁ – OFF → ON rate (1/s)
    omega_on_to_off: float  # ω₂ – ON → OFF rate (1/s)
    lambda_on: float  # arrival rate during ON state (1/s)

    # Service process
    mu: float  # service rate (1/s)

    # Run control
    horizon: float = 1e5  # simulation end time (seconds)
    seed: int | None = None  # RNG seed (None → time‑based)

    # Convenience helpers ------------------------------------------------
    @property
    def pi_on(self) -> float:
        """Steady‑state probability that IPP is in the ON state."""

        return self.omega_off_to_on / (
            self.omega_off_to_on + self.omega_on_to_off
        )

    @property
    def lambda_eff(self) -> float:
        """Long‑run average arrival rate."""

        return self.pi_on * self.lambda_on

    @property
    def rho(self) -> float:
        """Offered load (utilisation) under Poisson assumption."""

        return self.lambda_eff / self.mu


@dataclass(slots=True)
class SimulationResults:
    """Returned object after ``IPPQueueSimulator.run`` completes."""

    wait_times: np.ndarray  # per‑customer waiting times (before service)
    service_times: np.ndarray  # service times (Exp(μ)) – optional storage
    utilisation: float  # observed busy fraction (server time busy / horizon)
    event_log: list[EventRecord] | None = None  # only if log_events=True
    metrics: dict[str, Any] = field(default_factory=dict)  # populated by Metric.finalise()

    # Used when we run a finite queue length simulation
    total_arrivals: int = 0
    blocked: int = 0

    def pretty_print(self, params: Parameters) -> None:
        n = len(self.wait_times)
        mean_wq = self.wait_times.mean()
        mean_lq = mean_wq * params.lambda_eff  # Little’s Law
        print("\n—————— Simulation summary ——————")
        print(f" customers simulated : {n}")
        print(f" mean W_q  (sec)      : {mean_wq:.4f}")
        print(f" mean L_q             : {mean_lq:.4f}")
        print(f" utilisation (ρ)      : {self.utilisation:.4f}")
        if "L_time_avg" in self.metrics:
            print(f" time-avg L_q         : {self.metrics['L_time_avg']:.4f}")
        if self.metrics:
            print(" ancillary metrics    :")
            for k, v in self.metrics.items():
                print(f"   – {k:12s}: {v}")
        print("———————————————————————————————")


# =====================================================================
# Metric plug‑in framework
# =====================================================================
class Metric(ABC):
    """Base‑class / interface for all metric plug‑ins."""

    #: Human‑readable identifier.  Override in subclass.
    name: str = "metric‑base"

    # ------------------------------------------------------------------
    def on_event(self, record: EventRecord) -> None:
        """Hook called *immediately after* an event is created."""

    # ------------------------------------------------------------------
    @abstractmethod
    def finalise(self, results: SimulationResults) -> None:
        """Compute final value(s) and store under *results.metrics*."""


# ---------------------------------------------------------------------
# Metric 1 – Busy‑period statistics
# ---------------------------------------------------------------------
class BusyPeriodMetric(Metric):
    """Records consecutive intervals where the system is non‑empty."""

    name = "busy_periods"

    def __init__(self):
        self._current_start: float | None = None
        self._lengths: list[float] = []
        self._prev_q: int = 0  # queue length after previous event (0 at t=0)

    # .................................................................
    def on_event(self, record: EventRecord):  # noqa: D401 – imperative style
        q = record.queue_len
        # Start busy period
        if self._prev_q == 0 and q > 0:
            self._current_start = record.time
        # End busy period
        elif self._prev_q > 0 and q == 0 and self._current_start is not None:
            self._lengths.append(record.time - self._current_start)
            self._current_start = None
        self._prev_q = q

    # .................................................................
    def finalise(self, results: SimulationResults):
        lengths = np.asarray(self._lengths, dtype=float)
        if lengths.size == 0:
            results.metrics[self.name] = {"n": 0}
            return
        mean = float(lengths.mean())
        var = float(lengths.var(ddof=1)) if lengths.size > 1 else 0.0
        # 95 % CI on the mean via t‑distribution
        alpha = 0.05
        half_ci = float(
            stats.t.ppf(1 - alpha / 2, df=len(lengths) - 1)
            * lengths.std(ddof=1)
            / math.sqrt(len(lengths))
            if len(lengths) > 1
            else math.nan
        )
        results.metrics[self.name] = {
            "n": int(lengths.size),
            "mean": mean,
            "var": var,
            "95%CI": half_ci,
            "lengths": list(lengths)
        }

# ---------------------------------------------------------------------
# Metric 2 – Arrival‑stream burstiness/clumpiness (variance‑to‑mean ratio)
# ---------------------------------------------------------------------
class BurstinessMetric(Metric):
    """Variance‑to‑mean ratio of arrival counts in fixed‑width windows."""

    name = "burstiness"

    def __init__(self, window: float = 10.0):
        self.window = float(window)
        self._arrivals: list[float] = []

    # .................................................................
    def on_event(self, record: EventRecord):
        if record.event is EventType.ARRIVAL:
            self._arrivals.append(record.time)

    # .................................................................
    def finalise(self, results: SimulationResults):
        if not self._arrivals:
            results.metrics[self.name] = {"window": self.window, "vmr": math.nan}
            return

        arr = np.asarray(self._arrivals, dtype=float)
        t0 = arr.min()
        t_end = arr.max()
        n_bins = max(1, int(math.ceil((t_end - t0) / self.window)))
        counts, _ = np.histogram(
            arr,
            bins=n_bins,
            range=(t0, t0 + n_bins * self.window),
        )
        mean = counts.mean()
        var = counts.var(ddof=1) if counts.size > 1 else 0.0
        vmr = var / mean if mean > 0 else math.nan
        results.metrics[self.name] = {
            "window": self.window,
            "vmr": float(vmr),
            "mean_cnt": float(mean),
            "var_cnt": float(var),
            "n_win": int(n_bins),
        }


# =====================================================================
# Arrival‑process abstraction
# =====================================================================
class ArrivalProcess(ABC):
    """Polymorphic interface for anything that can supply arrival epochs."""

    @abstractmethod
    def next_arrival(self, now: float) -> float:
        """Return absolute time of next arrival strictly > *now*."""


class IPPArrivalProcess(ArrivalProcess):
    """Two‑state ON/OFF Interrupted Poisson Process."""

    OFF = 0
    ON = 1

    def __init__(self, params: Parameters, rng: random.Random | None = None):
        self.rng = rng or random.Random()
        self.omega1 = params.omega_off_to_on
        self.omega2 = params.omega_on_to_off
        self.lam_on = params.lambda_on
        self.state = self.OFF  # start OFF by convention
        self.t_next_state_change = self._exp(self.omega1)  # OFF→ON
        self.t_next_arrival = math.inf  # irrelevant until ON

    # ------------------------------------------------------------------
    def next_arrival(self, now: float) -> float:
        """Advance internal clocks until a customer arrives and return ts."""

        while True:
            if self.state == self.ON:
                if self.t_next_arrival < self.t_next_state_change:
                    # Arrival happens first
                    t = self.t_next_arrival
                    # schedule next arrival while still ON
                    self.t_next_arrival = t + self._exp(self.lam_on)
                    return t
                else:
                    # State change (ON→OFF) first
                    now = self.t_next_state_change
                    self.state = self.OFF
                    self.t_next_state_change = now + self._exp(self.omega1)
                    self.t_next_arrival = math.inf
            else:  # OFF state
                now = self.t_next_state_change
                self.state = self.ON
                self.t_next_state_change = now + self._exp(self.omega2)
                self.t_next_arrival = now + self._exp(self.lam_on)

    # ------------------------------------------------------------------
    def _exp(self, rate: float) -> float:
        return self.rng.expovariate(rate)


# =====================================================================
# Core simulator
# =====================================================================
class IPPQueueSimulator:
    """Discrete‑event simulator for an IPP/M/1 queue."""

    def __init__(
        self,
        params: Parameters,
        *,
        metrics: Sequence[Metric] | None = None,
        log_events: bool = False,
    ) -> None:
        self.params = params
        self.rng = random.Random(params.seed or time.time_ns())
        self.metrics = list(metrics) if metrics else []
        self.log_events = log_events
        self.event_log: list[EventRecord] | None = [] if log_events else None
        self.arrivals = IPPArrivalProcess(params, rng=self.rng)

        # Internal state -------------------------------------------------
        self.t = 0.0  # simulation clock
        self.queue: List[float] = []  # holds *service times* of waiting customers
        self.server_busy_until = 0.0
        self.next_arrival = self.arrivals.next_arrival(self.t)
        self.next_departure = math.inf  # none yet
        self.busy_time = 0.0
        self.area_q = 0.0
        self.last_event_time = 0.0

        # Collected samples ---------------------------------------------
        self.wait_times: List[float] = []
        self.service_times: List[float] = []

    # ------------------------------------------------------------------
    def run(self) -> SimulationResults:
        """Run until *params.horizon* and return `SimulationResults`."""

        horizon = self.params.horizon
        while self.t < horizon:
            # Next event -------------------------------------------------
            if self.next_arrival < self.next_departure:
                self._handle_arrival()
            else:
                self._handle_departure()

        # Final housekeeping --------------------------------------------
        util = self.busy_time / horizon if horizon > 0 else 0.0
        results = SimulationResults(
            wait_times=np.asarray(self.wait_times),
            service_times=np.asarray(self.service_times),
            utilisation=util,
            event_log=self.event_log,
        )

        # Metrics --------------------------------------------------------
        for m in self.metrics:
            try:
                m.finalise(results)
            except Exception as exc:  # pragma: no cover
                print(f"[WARN] metric '{m.name}' raised {exc}", file=sys.stderr)

        results.metrics["L_time_avg"] = self.area_q / self.params.horizon
        return results

    # ------------------------------------------------------------------
    # Event handlers
    # ------------------------------------------------------------------
    def _advance_area(self, new_time, q_now):
        self.area_q += q_now * (new_time - self.last_event_time)
        self.last_event_time = new_time
    
    def _handle_arrival(self):
        self._advance_area(self.next_arrival, len(self.queue))
        self.t = self.next_arrival
        svc = self.rng.expovariate(self.params.mu)
        if self.t >= self.server_busy_until:
            # Immediate service
            self.server_busy_until = self.t + svc
            self.next_departure   = self.server_busy_until
            self.busy_time += svc
            self.wait_times.append(0.0)
        else:
            wait = (self.server_busy_until - self.t) + sum(self.queue)
            self.wait_times.append(wait)
            self.queue.append(svc)
        # Bookkeeping
        self.service_times.append(svc)
        self.next_arrival = self.arrivals.next_arrival(self.t)
        self._log_event(EventType.ARRIVAL)

    def _handle_departure(self):
        self._advance_area(self.next_departure, len(self.queue))
        self.t = self.next_departure
        if self.queue:
            svc = self.queue.pop(0)
            self.server_busy_until = self.t + svc
            self.next_departure = self.server_busy_until
            self.busy_time += svc
        else:
            self.server_busy_until = self.t
            self.next_departure   = math.inf
        self._log_event(EventType.DEPARTURE)

    # ------------------------------------------------------------------
    def _log_event(self, etype: EventType):
        """Record an event and notify metrics."""

        q_len = len(self.queue)
        if etype is EventType.DEPARTURE and self.t < self.server_busy_until:
            q_len += 1  # customer in service counts toward queue length

        rec = EventRecord(time=self.t, queue_len=q_len, event=etype)

        # Notify metrics
        for m in self.metrics:
            m.on_event(rec)

        # Save in log if requested
        if self.event_log is not None:
            self.event_log.append(rec)